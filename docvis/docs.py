"""
Docvis' document infrastructure is used to render whole "documents" presenting data along with 
prose that sets it into context.

"Documents" are collections of HTML content that is generated by (usually) Markdown and 
data.

Organising documents
--------------------

* A Document is composed of Pages or other Documents
* A Page is composed of text (including markup) and data

Both Pages and Documents have a **logical name** and a **physical name** and
these names reflect the nested nature of Documents and their Pages. For example, 
suppose the following document structure where elements with a ``(d)`` correspond to
documents and ``(p)`` correspond to pages.

::

    main(d)
    |
    +--index(p)
    |
    +--results(d)
       |
       +--descriptive(p)
       |
       +--model_fitting(p)

In this structure, ``model_fitting`` is a Page and its **logical name** is
``main/results/model_fitting``. Its **physical name** will be ``main/results/model_fitting.html``
but it can be overriden when a ``Page`` object is instantiated.

Instantiating document objects
------------------------------

A Page is instantiated by its logical name, template content and data context. For 
example:

::

    Page("index",
         "# Welcome to this page\\n\\nHello {user_name}",
         {"user_name":"some user"})

For more details please see the ``Page`` class further below.

A Document is instantiated by its logical name and content, where content is a list of 
either Document or Page objects. For example:

::
    Document("main",
             [
              Page("index",
                   "# Welcome\\n\\nHere be {{animal}}",
                   {"animal":"dragons"})
             ]
           )

For more details please see the ``Document`` class further below.

Template utilities
------------------

Pages are ``DefaultDocVisMarkdownDiv`` objects with the additional availability of 
the template function ``link_to``.

``link_to`` accepts a link description and path to another page and creates the 
correct link in a page. For example:

::

    d = Document("main",
                 [
                     Page("p1", 
                          "# Page 1\\n\\nThis is page 1\\n\\n{{link_to('Page 2','main/p2')}}",
                          {}
                         ),
                     Page("p2",
                          "# Page 2\\n\\nThis is page 2\\n\\n{{link_to('Page 1','main/p1')}}",
                          {})
                 ]
                )


-----


"""

from .core import RenderableElement, HTMLPage, HTMLBody, HTMLTitle, HTMLStylesheet, HTMLMeta, HTMLHead
from .utils import DefaultDocVisMarkdownDiv
import pathlib
import os
import copy

class RenderableDocElement(RenderableElement):
    """
    Base class for all objects that can produce *hard-copies*.

    :param logical_name: The logical name of the element.
    :type logical_name: str
    :param physical_name: The physical name of the element (i.e the name it will appear as in the file-system).
    :type physical_name: str
    :param parent: The Document this element is parented to
    :type parent: Document
    """
    def __init__(self, logical_name, physical_name=None, parent=None):
        # TODO: HIGH, doc_name needs to be regexp checked that it can be used as a path.
        self._logical_name = logical_name
        self._physical_name = physical_name if physical_name is not None else logical_name
        self._parent = parent
        
    @property
    def logical_name(self):
        return self._logical_name

    @property
    def physical_name(self):
        return self._physical_name

    @property
    def parent(self):
        return self._parent

    def get_fs_path(self):
        """
        Return the path of a given file on the filesystem
        """
        # Note here that in the case of the fs path, the top level
        # element does not appear in the path because the top level 
        # Document will create a directory where all of its content lives in.
        if self.parent is not None:
            prefix = self.parent.get_fs_path()
            return f"{prefix}{'/' if len(prefix)!=0 else ''}{self.physical_name}"
        else:
            return ""

    def get_root(self):
        """
        Return the root object of a given hierarchy.
        """
        if self.parent is not None:
            return self.parent.get_root()
        else:
            return self

    def collect_parents(self):
        """
        Collect all Document parents from a given level in the hierarchy *and above*.
        """
        if self._parent is not None:
            return {self._parent} | self._parent.collect_parents()
        else:
            return set()


class Document(RenderableDocElement):
    """
    A document is composed of other Documents or Pages


    :param doc_name: A logical name for the document
    :type doc_name: str
    :param content_elements: A list of docvis.docs.Page that represent each content page in the document
    :type content_elements: List[docvis.docs.Page]
    :param dir_name: The directory name if it has to be set explicitly.
    :type dir_name: str
    """
    def __init__(self, doc_name, content_elements, dir_name = None):
        super().__init__(doc_name)
        # Check that no circular references are added
        prohibited_elements = map(id, self.collect_parents())
        for an_element in content_elements:
            if id(an_element) in prohibited_elements:
                raise Exception(f"Element {an_element.logical_name}({an_elemen.physical_name} is causing a circular reference")

        # Content elements should not have already been parented
        for an_element in content_elements:
            if an_element.parent is not None:
                raise Exception(f"{an_element} already belongs to a document hierarchy")

        self._content_elements = {}
        self._content_elements |= dict([(c_key, c_el) for c_key, c_el in map(lambda x:(x.logical_name, x), content_elements)])

        # All elements are parented to the current element
        # This works because all elements are copies of the originals and can have 
        # different parents
        for an_element in self._content_elements.values():
            an_element._parent = self

    def render(self):
        doc_path = pathlib.Path(self.physical_name)
        # If the directory does not exist in the CWD, create it
        if not doc_path.exists():
            doc_path.mkdir(parents=True)
        # Save the CWD
        cwd = os.getcwd()
        # Switch to the doc working dir
        os.chdir(doc_path)
        # Build all content 
        for a_content_el in self._content_elements.values():
            a_content_el.render()
        # Restore the cwd
        os.chdir(cwd)

    def element_by_path(self, path):
        """
        Return a given element by its path or raise exception if it cannot be located.

        :param path: Path to a given element, **from its root**.
        :type path: str
        """
        path_elements = path.split("/")
        root_logical_name = self.get_root().logical_name 
        if path_elements[0] == self.logical_name:
            target_element = self
        else:
            try:
                target_element = self._content_elements[path_elements[0]]
            except KeyError:
                raise Exception(f"{path_elements[0]} does not exist")
        if isinstance(target_element, Page) and len(path_elements) > 1:
            raise Exception(f"{path_elements[0]} does not exist")
        if isinstance(target_element, Document) and len(path_elements) > 1:
            return target_element.element_by_path("/".join(path_elements[1:]))
        return target_element


class Page(RenderableDocElement):
    """
    Resolves to an HTML page that renders text and data.


    :param page_name: A logical name for the page
    :type page_name: str
    :param template: The Markdown content of the page
    :type template: str
    :param data_context: A mapping from variable names to values.
    :type data_context: dict
    :param extra_resources: A list of external resources required for this element (e.g. stylesheets, scripts).
    :type extra_resources: list[str]
    :param file_name: The filename for this page if it has to be set explicitly.
    :type file_name: str
    """
    def __init__(self, page_name, template, data_context, extra_resources=[], file_name=None):
        super().__init__(page_name)
        self._template = template
        self._data_context = data_context
        self._extra_resources = extra_resources
        # TODO: HIGH, file_name needs to be regexp checked that it can be used as a path.
        self._physical_name  = file_name if file_name is not None else f"{page_name}.html"

    def make_path_relative(self, from_path, to_path):
        # Find their common root
        pc_from = from_path.split("/")
        pc_to = to_path.split("/")
        u = 0
        for k in range(0, max(len(pc_from), len(pc_to))):
            pc_from_v = pc_from[k] if k < len(pc_from) else None
            pc_to_v = pc_to[k] if k < len(pc_to) else None
            if pc_from_v == pc_to_v:
                u += 1
        if len(pc_to) >= len(pc_from):
            # Going to
            return "/".join(pc_to[(u):]) 
        else:
            # Coming from
            return ("/".join([".."] * (len(pc_from)-(u+1)))) + "/" + "/".join(pc_to[u:])
            

    def _link_to_element(self, desc, path):
        return f"<a href=\"{self.make_path_relative(self.get_fs_path(), self.get_root().element_by_path(path).get_fs_path())}\">{desc}</a>"

    def _get_HTMLPage(self): 
        # Build the page that will be rendered
        return HTMLPage(HTMLBody([
                                  DefaultDocVisMarkdownDiv(self._template, 
                                                           self._data_context|{"link_to":self._link_to_element},
                                                           external_resources=self._extra_resources)
                                 ]),
                                 HTMLHead([
                                           HTMLTitle(self.logical_name),
                                           HTMLMeta({"charset":"utf-8"}),
                                          ])
                       )

    def render(self):
        with open(self.physical_name,"wt") as fd:
            fd.write(self._get_HTMLPage().render())

    
